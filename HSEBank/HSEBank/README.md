# HSEBank – финансовый модуль
## Отчёт по архитектуре и реализации

## 1. Назначение и реализованный функционал

Приложение HSEBank представляет собой консольную систему для ведения личных финансов. В текущей версии реализованы следующие возможности:

- Управление доменными сущностями:
    - **Счета** (`BankAccount`);
    - **Категории доходов и расходов** (`Category`);
    - **Операции по счетам** (`Operation`).
- Аналитика:
    - сравнение суммарных доходов и расходов;
    - свод по категориям с учётом их типа;
    - динамика по месяцам;
    - определение топ-3 категорий по расходам (внутренняя стратегия).
- Формирование консольного отчёта на основе результатов аналитики.
- Импорт и экспорт данных в форматах **CSV / JSON / YAML**.
- Автоматический и ручной пересчёт балансов по счетам.
- Событийная модель (**EventBus**) для пересчёта баланса и аудита операций.
- Система команд с:
    - историей выполнения;
    - поддержкой Undo;
    - логированием;
    - измерением времени выполнения.
- DI-контейнер и кеширующие прокси для репозиториев.
- Автотесты основных сценариев:
    - сервисы и фасады;
    - события и кеш;
    - аналитика и команды;
    - импорт / экспорт.

---

## 2. Архитектура и доменная модель

### 2.1. Слоистая структура

1. **Domain (Entities)**
    - `BankAccount`, `Category`, `Operation` – простые POCO-классы с минимальной логикой (например, `Operation.Validate()`, вычисление баланса и т.п.).
    - Доменные сущности реализуют интерфейс `IVisitable` для поддержки механизма экспорта.

2. **Application / Services**
    - Сервисы: `AccountService`, `CategoryService`, `OperationService` – отвечают за бизнес-логику:
        - валидацию входных данных;
        - пересчёт балансов;
        - восстановление состояния счёта;
        - проверку типов категорий и операций.
    - Аналитика:
        - контекст `AnalyticsContext`;
        - стратегии: `IncomeVsExpenseStrategy`, `ByCategoryStrategy`, `MonthlyTrendStrategy`, `TopExpenseCategoriesStrategy`.
    - Командная подсистема:
        - интерфейс `ICommand`;
        - реализация-обёртка `ActionCommand`;
        - `CommandManager` и декораторы команд.

3. **Facades**
    - `AccountFacade`, `OperationFacade`, `CategoryFacade` – тонкий слой между UI и сервисами, инкапсулирующий типичные сценарии (например, создание счёта вместе с начальной операцией).

4. **Infrastructure**
    - DI-контейнер: `ServiceContainer` + интерфейс `IServiceProvider`.
    - Репозитории:
        - in-memory: `BankAccountRepositoryInMemory`, `CategoryRepositoryInMemory`, `OperationRepositoryInMemory`;
        - кеширующие прокси: обобщённый `RepositoryCacheProxy<T>` и специализированные прокси.
    - Сериализация:
        - `CsvSerializer`, `YamlSerializer`, общий интерфейс `IDataSerializer`.

5. **Import / Export**
    - Импорт:
        - абстракция `ImportTemplate`;
        - конкретные импортёры: `CsvImporter`, `JsonImporter`, `YamlImporter`.
    - Экспорт:
        - `IExportVisitor`, `CsvExportVisitor`, `JsonExportVisitor`, `YamlExportVisitor`.
    - Фасад: `DataTransferService`, объединяющий импорт и экспорт.

6. **Events**
    - Инфраструктура событий: `EventBus`, `IEvent`, `IEventHandler<TEvent>`.
    - События домена: `OperationCreatedEvent`, `AccountDeletedEvent`.
    - Обработчики:
        - `AuditLogHandler` (аудит операций и удалений);
        - `BalanceUpdateHandler` (автоматический пересчёт баланса при создании операций).

7. **Reports**
    - Компоненты отчёта:
        - `Report`, `IReportComponent`, `ReportTitle`, `ReportTable`, `ReportSummary`.
    - Строитель: `IReportBuilder`, `ConsoleReportBuilder`.
    - Директор: `ReportDirector`, оркестрирующий построение отчёта.

8. **UI**
    - Основной консольный интерфейс: `ConsoleUi`.
    - Точка входа: `Program.Main` + `Bootstrapper.Configure()` – конфигурация DI-контейнера и запуск UI.

---

## 3. Восемь основных паттернов GoF

### 3.1. Фасад (Facade) – упрощение работы с предметной областью

**Где используется:**

- `AccountFacade` (`IAccountFacade`);
- `OperationFacade` (`IOperationFacade`);
- `CategoryFacade` (`ICategoryFacade`);
- `DataTransferService` как фасад над подсистемой импорта/экспорта.

**Как реализовано:**

- `AccountFacade.CreateAccountWithInitialOperation`:
    - создаёт счёт через `IAccountService`;
    - при положительном начальном балансе формирует операцию-доход через `IOperationService`;
    - инициирует пересчёт баланса.
- `OperationFacade` и `CategoryFacade` предоставляют «плоский» API для UI.
- `DataTransferService` скрывает детали `ImportTemplate`, конкретных импортёров и `IExportVisitor` за методами `ImportAll` и `ExportAll`.

**Зачем:**

- UI (`ConsoleUi`) не зависит от внутренней структуры сервисов и репозиториев.
- Упрощается интеграционное тестирование: `AccountFacadeTests`, `OperationFacadeTests` проверяют бизнес-сценарии целиком.
- Снижается связанность между слоями, повышается модульность.

---

### 3.2. Команда (Command) – унификация действий и поддержка Undo

**Где используется:**

- Базовый интерфейс: `ICommand`.
- Обёртка: `ActionCommand`.
- Команда аналитики: `ConsoleUi.AnalyticsCommand`.
- Инвокер: `CommandManager`.

**Как реализовано:**

- Любое пользовательское действие (создание счёта, добавление операции, импорт/экспорт, пересчёт балансов и т.д.) представлено объектом `ICommand`.
- `CommandManager.ExecuteCommand`:
    - оборачивает команду в декораторы (логирование, измерение времени);
    - выполняет её;
    - сохраняет в стек истории для дальнейшего Undo.
- `UndoLastCommand` извлекает команду из стека и вызывает её `Undo()`.

**Зачем:**

- Централизованное управление пользовательскими сценариями.
- Унифицированный механизм отмены действий для большинства операций.
- Единая точка подключения кросс-срезных аспектов (логирование, тайминг) без модификации бизнес-логики.

---

### 3.3. Декоратор (Decorator) – логирование и замер времени команд

**Где используется:**

- Логгер: `ILogger`, `ConsoleLogger`.
- Декораторы:
    - `LoggedCommandDecorator`;
    - `TimeCommandDecorator`.

**Как реализовано:**

- `CommandManager.ExecuteCommand` формирует цепочку декораторов:
    - `TimeCommandDecorator.Execute()` измеряет длительность выполнения вложенной команды и выводит результат в консоль;
    - `LoggedCommandDecorator.Execute()/Undo()` пишет лог до и после выполнения команды.

**Зачем:**

- Добавление логирования и профилирования без изменения кода команд.
- Возможность комбинировать несколько декораторов последовательно.
- Чёткое разделение обязанностей: команды реализуют бизнес-логику, декораторы отвечают за инфраструктурные аспекты.

---

### 3.4. Стратегия (Strategy) – сменяемые алгоритмы аналитики

**Где используется:**

- Интерфейс: `IAnalyticsStrategy`.
- Реализации:
    - `IncomeVsExpenseStrategy`;
    - `ByCategoryStrategy`;
    - `MonthlyTrendStrategy`;
    - `TopExpenseCategoriesStrategy`.
- Контекст: `AnalyticsContext`.

**Как реализовано:**

- `AnalyticsContext` хранит текущую стратегию (`IAnalyticsStrategy`) и делегирует ей выполнение анализа.
- В `ConsoleUi.ShowAnalytics()` стратегия выбирается на основе ввода пользователя.
- В рантайме возможна смена стратегии через `SetStrategy`.

**Зачем:**

- Расширяемость аналитики без изменения существующего кода (OCP).
- Чёткое разделение различных алгоритмов анализа.
- Простота добавления новых стратегий (например, аналитика по счетам) без изменения UI и контекста.

---

### 3.5. Шаблонный метод (Template Method) – общий алгоритм импорта

**Где используется:**

- Абстрактный класс: `ImportTemplate`.
- Конкретные реализации:
    - `CsvImporter`;
    - `JsonImporter`;
    - `YamlImporter`.

**Как реализовано:**

- `ImportTemplate.Run()` задаёт общий скелет алгоритма:
    1. `Read(path)` – чтение исходных данных;
    2. `Parse(...)` – парсинг в доменные сущности;
    3. `Validate()` – базовая проверка корректности (упрощённая);
    4. `Upsert(...)` – вставка/обновление сущностей в репозиториях.
- Подклассы переопределяют `Read` и `Parse`:
    - `CsvImporter` читает три отдельных файла: `accounts.csv`, `operations.csv`, `categories.csv`;
    - `JsonImporter` работает с одним JSON-файлом и распределяет данные по сущностям;
    - `YamlImporter` извлекает блоки по ключам.

**Зачем:**

- Единый алгоритм для всех форматов импорта при различающихся источниках/форматах.
- Устранение дублирования кода.
- Упрощение добавления новых импортёров (например, XML).

---

### 3.6. Посетитель (Visitor) – экспорт в разные форматы

**Где используется:**

- Интерфейсы: `IExportVisitor`, `IVisitable`.
- Реализации:
    - `CsvExportVisitor`;
    - `JsonExportVisitor`;
    - `YamlExportVisitor`.
- Доменные сущности: `BankAccount`, `Category`, `Operation` реализуют `Accept(IExportVisitor)`.

**Как реализовано:**

- Каждая сущность в методе `Accept` вызывает `visitor.Visit(this)`.
- В `DataTransferService.ExportAll`:
    - происходит обход всех счетов, операций и категорий;
    - для каждой сущности вызывается `Accept(visitor)`;
    - выбранный `ExportVisitor` накапливает данные и сохраняет их в нужном формате.

**Зачем:**

- Добавление новых форматов экспорта без изменения доменной модели.
- Один обход графа объектов – несколько вариантов сериализации.
- Инкапсуляция логики формата файла внутри конкретного визитора.

---

### 3.7. Прокси (Proxy) – кеширование репозиториев

**Где используется:**

- Обобщённый кеширующий прокси: `RepositoryCacheProxy<T>`.
- Специализированные прокси:
    - `BankAccountRepositoryCacheProxy`;
    - `CategoryRepositoryCacheProxy`;
    - `OperationRepositoryCacheProxy`.

**Как реализовано:**

- Прокси реализует тот же интерфейс `IRepository<T>`, что и исходный репозиторий.
- `GetAll()`:
    - при первом вызове обращается к реальному репозиторию и кеширует результат;
    - последующие вызовы используют кеш.
- `GetById(Guid id)` также кеширует данные по идентификатору.
- При `Add`/`Remove` кеш сбрасывается.

**Зачем:**

- Снижение количества обращений к хранилищу (в том числе при возможном переходе на БД).
- Прозрачность для сервисов и фасадов: они не знают о наличии кеша.
- Возможность заменить in-memory реализацию на внешнюю БД, сохранив прокси.

---

### 3.8. Строитель (Builder) – конструирование отчёта

**Где используется:**

- Компоненты:
    - `Report` (композит);
    - `IReportComponent`, `ReportTitle`, `ReportTable`, `ReportSummary`.
- Строитель: `IReportBuilder`, `ConsoleReportBuilder`.
- Директор: `ReportDirector`.

**Как реализовано:**

- `ReportDirector.BuildAnalyticsReport(AnalyticsResult analytics)`:
    - добавляет заголовок (`AddTitle`);
    - добавляет таблицу данных (`AddTable`);
    - добавляет итоговую часть (`AddSummary`);
    - возвращает готовый отчёт через `GetReport()`.
- `Report.Render()` выводит отчёт в консоль, последовательно рендеря все компоненты.

**Зачем:**

- Разделение:
    - *что* должно быть в отчёте (директор),
    - *как* это визуализируется (конкретный строитель).
- Возможность добавить, например, `HtmlReportBuilder` без изменения логики аналитики и директора.

---

### Дополнительно: Наблюдатель (Observer)

Хотя паттерн Observer не входит в основной список «топ-8», он явно присутствует в архитектуре:

- Инфраструктура: `EventBus`, `IEvent`, `IEventHandler<TEvent>`, события `OperationCreatedEvent`, `AccountDeletedEvent`.
- Подписчики:
    - `AuditLogHandler` – аудит операций и удалений;
    - `BalanceUpdateHandler` – автоматический пересчёт баланса при создании операций.

Это классический вариант Publisher–Subscriber, отделяющий публикацию бизнес-событий от их обработки.

---

## 4. SOLID и GRASP

**SOLID:**

- **SRP (Single Responsibility Principle)**:
    - сервисы (`AccountService`, `OperationService`, `CategoryService`) отвечают за бизнес-правила;
    - фасады – за сценарии использования;
    - декораторы – за логирование и измерение времени;
    - импортёры – за импорт данных;
    - визиторы – за экспорт.
- **OCP (Open/Closed Principle)**:
    - стратегии аналитики, визиторы экспорта, импортёры, строители отчётов расширяются добавлением новых классов без изменения существующих.
- **LSP (Liskov Substitution Principle)**:
    - реализации интерфейсов (`IRepository<T>`, `IAnalyticsStrategy`, `IExportVisitor`, `IReportBuilder`) взаимозаменяемы.
- **ISP (Interface Segregation Principle)**:
    - интерфейсы небольшие и предметно-ориентированные (`ICategoryService`, `IAccountService`, `IRepository<T>`).
- **DIP (Dependency Inversion Principle)**:
    - зависимости передаются через интерфейсы и DI-контейнер (`ServiceContainer`), а не создаются напрямую.

**GRASP:**

- **Controller**: `ConsoleUi` выступает контроллером пользовательских сценариев.
- **Low Coupling / High Cohesion**:
    - фасады и сервисы сгруппированы по предметной области;
    - зависимости между слоями минимальны.
- **Indirection**:
    - `EventBus` и фасады служат посредниками между UI, сервисами и инфраструктурой.

---

## 5. Тестовое покрытие

В проекте реализован набор юнит-тестов для ключевых компонентов:

- `AccountServiceTests`, `CategoryServiceTests`, `OperationServiceTests` – проверка бизнес-логики сервисов.
- `AccountFacadeTests`, `OperationFacadeTests` – проверка взаимодействия фасадов и сервисов.
- `AnalyticsTests`, `TopExpenseCategoriesStrategyTests` – корректность аналитических стратегий.
- `CommandTests` – поведение команд, декораторов и `CommandManager`.
- `EventBusTests` – доставка событий подписчикам.
- `RepositoryCacheProxyTests` – работа кеширующего прокси.
- `DataTransferServiceTests` – корректность экспорта в CSV.

---